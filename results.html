<!DOCTYPE html>
<html lang="fi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tulossivu</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="icon" type="image/png" href="Kuvat/palkinto.png">
</head>
<body>
    <header class="hero">
        <img src="Kuvat/palkinto.png" alt="logo" class="heropic">
        <h1>Dokathlon 2024</h1>
    </header>
    <nav>
        <a href="index.html">Kotisivu</a>
        <a href="about.html">Infosivu</a>
        <a href="history.html">Historia</a>
        <a href="ranking.html">P4P ranking</a>
        <a href="results.html">Tulokset</a>
    </nav>
    <div class="container">
        <div class="content">
            <h2>Tulokset</h2>
            <p>Täältä löydät tulokset eri kilpailutapahtumista. Kilpailijat saavat pisteitä suoritustensa perusteella, ja ne on laskettu taulukkoon alla. Kilpailusuoritus pisteytetään antamalla voittajalle 19 pistettä ja lajin viimeiselle yksi piste. Tasatilanteessa molemmat osallistujat saavat korkeamman pistemäärän.</p>
            <div class="results-table">
                <h3>Tapahtumatulokset</h3>
                <div style="overflow-x: auto;">
                    <table id="eventResultsTable">
                        <thead>
                            <tr></tr>
                        </thead>
                        <tbody></tbody>
                    </table>
                </div>
            </div>

            <div class="points-table">
                <h3>Pisteet</h3>
                <div style="overflow-x: auto;">
                    <table id="pointsTable">
                        <thead>
                            <tr></tr>
                        </thead>
                        <tbody></tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>
    <footer>
        <p>&copy; 2024 Dokathlon. Kaikki (oikeudet) pidätetään.</p>
    </footer>

    <script>
        const API_KEY = 'AIzaSyDD90a2fkngn3OCYwJpijcZtyWwohmWJ8Q'; 
        const SHEET_ID = '1VmCpTWbrkG5XXCjxoXsAb6mGIcIVIrlj4e-YrnmSwq4'; 
        const rangesA1 = ['Taulukko1!A1:T1', 'Taulukko1!A2:T21']; 

        async function fetchData() {
            try {
                const rangeParams = rangesA1.map(range => `ranges=${encodeURIComponent(range)}`).join('&');
                const url = `https://sheets.googleapis.com/v4/spreadsheets/${SHEET_ID}/values:batchGet?${rangeParams}&key=${API_KEY}`;
                const response = await fetch(url);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const data = await response.json();
                return data.valueRanges;
            } catch (error) {
                console.error('Error fetching data:', error);
                return null;
            }
        }

        function calculatePoints(results) {
            const points = {};
            const eventCount = results[0].length - 1;
            const eventTypes = [0, 1, 1, 0, 0, 1, 1, 1, 1, 0]; // 0 = higher is better, 1 = lower is better

            results.forEach(row => {
                const participant = row[0];
                const scores = row.slice(1).map(score => {
                    const num = parseFloat(score);
                    return isNaN(num) ? null : num;
                });

                points[participant] = {
                    totalPoints: 0,
                    eventPoints: Array(eventCount).fill(0),
                    scores: scores
                };
            });

            for (let eventIndex = 0; eventIndex < eventCount; eventIndex++) {
                const eventScores = Object.entries(points)
                    .map(([participant, data]) => ({
                        participant,
                        score: data.scores[eventIndex]
                    }))
                    .filter(entry => entry.score !== null);

                if (eventScores.length === 0) continue;

                eventScores.sort((a, b) =>
                    eventTypes[eventIndex] ? a.score - b.score : b.score - a.score
                );

                let currentPoints = 19;
                let lastScore = null;
                let tieCount = 0;

                for (let i = 0; i < eventScores.length; i++) {
                    const { participant, score } = eventScores[i];

                    if (score !== lastScore) {
                        currentPoints -= tieCount;
                        tieCount = 0;
                        lastScore = score;
                    }

                    points[participant].eventPoints[eventIndex] = currentPoints;
                    points[participant].totalPoints += currentPoints;
                    tieCount++;
                }
            }

            return points;
        }

        function populateTables(data) {
            if (!data || data.length < 2) {
                console.error('Invalid data.');
                return;
            }

            const headers = data[0].values[0];
            const results = data[1].values;

            // Results table
            const eventResultsHead = document.querySelector('#eventResultsTable thead tr');
            const eventResultsBody = document.querySelector('#eventResultsTable tbody');
            eventResultsHead.innerHTML = headers.map(h => `<th>${h}</th>`).join('');
            eventResultsBody.innerHTML = results.map(row => `
                <tr>${row.map(cell => `<td>${cell}</td>`).join('')}</tr>
            `).join('');

            // Points table
            const points = calculatePoints(results);
            const pointsTableHead = document.querySelector('#pointsTable thead tr');
            const pointsTableBody = document.querySelector('#pointsTable tbody');
            pointsTableHead.innerHTML = `<th>Nimi</th>${headers.slice(1).map(h => `<th>${h}</th>`).join('')}<th>Yht.</th>`;

            const sorted = Object.entries(points).sort((a, b) => b[1].totalPoints - a[1].totalPoints);
            pointsTableBody.innerHTML = sorted.map(([name, data]) => `
                <tr>
                    <td>${name}</td>
                    ${data.eventPoints.map(p => `<td>${p}</td>`).join('')}
                    <td>${data.totalPoints}</td>
                </tr>
            `).join('');
        }

        fetchData().then(populateTables).catch(error => {
            console.error('Final error:', error);
        });
    </script>
</body>
</html>
